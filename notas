

let nombres = ['pedro','javier','italo','pePE']
let grades = [10,10,233,55,64,44];
function getNumberOfGrades(grade) {
  return grade.length; //numero de elementos
}
console.log(getNumberOfGrades('EL NUMERO DE GRADOS ES',grades))

function getFirstChar(name){
  return name[0];//primer elemento del array
}


console.log(getFirstChar(nombres));
function getLastChar(name){
  return name[name.length -1]//ultimo elemento del array
}
console.log(getLastChar(nombres));

// function getLowerCase(n){
//   return n.toLowerCase();
// }
// console.log(getLowerCase(nombres))//no sirve

function getDescription(text){
  if(text.length > 10){
    return text.substring(0, 10)+ '...';
  }
  return text;
}

function elementAdd(elemento){
 return elemento.push('elemento123?!23');
}

//console.log(nombres);
elementAdd(nombres);
console.log(nombres);

grades.forEach(function(grade){
  console.log(grade)//devuelve el arreglo entero
})
nombres.forEach(function(nombre){
  console.log(nombre)//devuelve el arreglo entero
})

let n =grades.filter(function(n){
  return true;//retorna el arreglo completo sin filtrar nada
})
console.log(n);

nombres.filter(function(n){
  console.log(n)
})
console.log('////////////////')

function a(years, searchYear){
  return years.find(function(year){
    return year === searchYear;
  })
}
console.log(a(nombres,'javier'))


nombres.map(function(strings){
     console.log(strings.length)
  })

  function getStringSizes(strings) {//devuelve cuantos string tiene cada pocicion
    return strings.map(function(strings){
        return strings;

    }).length
}
/////////////')

// function getVotersCount(strings){
//   return strings.filter(function(age){
//       return age
//   })
// }

// function le(grad){
//   return grad.filter(function(age){
//     return age >=18 
//   }).length;
// }
let edad = [10,10,233,233,23,23]

function le(grad){
  return grad.filter(function(age){
    return age >=18
})
}
let j = le(edad)
console.log(j)

function le2(grades){
   return grades.filter(function(grades){
    return grades >=18
   }).length
}
const t = le2(edad)
console.log(t)

//var allowed = (age > 18) ? 'yes' : 'no';
var elvisLives = 19 > 18 ? "es mayor de 18" : "No";
console.log(elvisLives)

console.log(19 >18?true:false)

var firstCheck = false,
    secondCheck = false,
    access = firstCheck ? "Acceso Denegado" : secondCheck ? "Acceso Denegado" : "Acceso Permitido";

console.log( access ); // muestra "Acceso Permitido"
var arr = ['a','b','c']
console.log(arr.toString());//a,b,c
console.log(arr.join('-'));//a-b-c
console.log(arr.pop());//c
console.log(arr.push(firstCheck));//c
console.log(arr.shift());//a
console.log(arr.unshift('ww'));//ww,b,false
console.log(arr.slice());//[ 'ww', 'b', false ]
console.log(arr.reverse());//[ false, 'b', 'ww' ]

function add() {
  var sum = 0;
  for (var i = 0, j = arguments.length; i < j; i++) {
    sum += arguments[i];
  }
  return sum;
}
console.log(add(2, 3, 4, 5)); // 14

function fnV2(){//devuelve el arreglo * 2 cada pos
  let m=[];
  for(var i=0, j = arguments.length;i<j;i++){
     m[i] = arguments[i]*2
  }
  return m
}
console.log(fnV2(2,2,2,5))

function makePerson(first, lastname){
  return {
    first : first,
    lastname : lastname
  }
}
function personName(person){
  return person.first+ ' ' +person.lastname;
}
function personFullNameReversed(person){
  return person.lastname +','+ person.first;
}

var nom =  makePerson('tito','fabi')
console.log(personName(nom))

function makePerson2(id,nom,dni){
  return {
    id : id,
    nom : nom,
    dni : dni
  }
}

function personV(data){
  return data.id +' '+data.nom+' '+data.dni
}
var per = makePerson2('e','pablo','182829')
console.log(personV(per))

function makePerson3(first, last){
    this.first = first,
    this.last = last
   
  };
  
  makePerson3.prototype.nomFn = function(){
    return this.first.toUpperCase();
  };
  //var a = makePerson3('Pablo','Dos Santos')
  //console.log(a.fullnameReversed())
  var obj = new makePerson3('pablo', 'dos sanot')
  console.log(obj.nomFn)
  console.log('////////////////////////////////')
  
function persona(first, last){
  this.first = first;
  this.last = last;
}
persona.prototype.fullname = function(){
  return this.first + ' ' + this.last;
}
persona.prototype.fullnameR = function(){
  return this.last + ' ' + this.first;
}
var Per = new persona('pablo','dos santos')

function persona1(dato1, dato2){
  this.dato1 = dato1;
  this.dato2 = dato2;
}

var avg = function(){
  let sum = 0;
  for(var i=0,j = arguments.length;i<j;i++){
    sum += arguments[i]
  }
  return sum / arguments.length
}
console.log(avg(7,7,7))

console.log('////////////////////////////////')
function person3(first, last){
  this.first = first;
  this.last = last;
}
person3.prototype.fuln = function(){
  return this.first+' '+this.last;
}
var Per3 = new person3('pablo','dos santos')
var dd = Per3.fuln()
console.log(dd)

var s = 'Simon';
//s.reversed(); // TypeError en la lÃ­nea 1: s.reversed no es una funciÃ³n

String.prototype.reversed = function() {
  var r = '';
  for (var i = this.length - 1; i >= 0; i--) {
    r += this[i];
    console.log(r)
  }
  return r;
};
console.log(s.reversed()); // nomiS

let rrhh = 'Pablooooooooof'
 rrhh = rrhh.length - 1
console.log(rrhh)
rrhh = 'Pablooooooooof'
String.prototype.reversa = function(){
  var l = '';
  for(var i = this.length -1;i >= 0;i--){
    l += this[i]
    //console.log(l);
 }
 return l
}
console.log(rrhh.reversa())

console.log('ESTA ES UNA PRUEBA DE STRING REVERTIENDO TODO LO QUE HEMOS ECHO HASTA EL MOMENTO '.reversa())
console.log('hola');

// var toString = 'oooooooooo'

function mak(first, last){
  this.first = first,
  this.last = last
  
};
mak.prototype.toString = function() {
  //return '<Person: ' + this.fullName() + '>';
}

var Mak = new mak('pabloto', 'santos dos')
var ss = Mak.toString()
console.log(ss)

console.log('////////////////////////////////')

const tagline = 'MDN - Resources for developers, by developers';
console.log(tagline.indexOf('R'))//R
console.log(tagline.slice(0,3))

let sumnn = (x,y) =>x+y //funcion flecha que suma dos numeros
let addas = (x, y) => { return x + y; };

console.log(typeof addas)

let ede = [1,2,3];
ede.sort(function(a,b){ 
    return b - a; 
});
console.log(ede); // [6,4,2]
let ede2 = [1,10,100];
ede2.sort((a,b) => b - a);
console.log(ede2); // [6,4,2]
var arre = [55,2,3,4,34,4,4,22];
function compare(a,b){return(a-b)}
arre.sort(compare)
console.log(arre.sort(compare)); // [1,2,3]
arr.sort((a,b)=>a-b)
arr.sort((a,b)=>a-b)
arr.sort((a,b)=>a-b)
let arre2a = ['rÃ©servÃ©', 'Premier', 'ClichÃ©', 'communiquÃ©', 'cafÃ©', 'Adieu'];
//console.log(arre2a.sort((a, b) => a.localeCompare(b, 'ES', { ignorePunctuation: true })))
var result = arre2a.map(function(el,i){
  return {index: i, value: el.toLowerCase()};
});
console.log(result) 

let arre2b = ['rÃ©servÃ©', 'Premier', 'ClichÃ©', 'communiquÃ©', 'cafÃ©', 'Adieu'];
var resultado2 = arre2b.map(function(na,nb){
  return {pos: nb ,valor: na}
})
console.log(resultado2)
let arre2c = ['pablo', 'daniel', 'pablue', 'vale', 'cafÃ©', 'Adieu'];
let af = arre2c.map(a => a.length)
console.log(af)

function show(){
   return x => x + arguments[0]
}

let display = show(3, 3);
let resultA = display(5);
console.log(display)


function filterA(numbers, callback){
  let resultsA =[];
  for(const number of numbers){
    if (callback(number)){
      resultsA.push(number);
    }
  }
  return resultsA;
}
let numbers2 = [1, 2, 4, 7, 3, 5, 6];
let oodNum = filterA(numbers2, function(number){
  return number % 2 != 0;
});
console.log(oodNum)

function ff(numeros,callback){
  let result = [];
  for(const numero of numeros){
    if(callback(numero)){
      result.push(numero)
    }
  }
  return result
}

let ns = [2,3,4,2,5,3,9,9,3,3];
console.log('todos los nuemros: ' + ns)
let variableImp = ff(ns,(numero)=>numero % 2 !=0);
console.log('impares: ' + variableImp)
let variablePar = ff(ns,(numero)=>numero %2 ==0);
console.log('numero Pares: ' + variablePar)

// let oodNum = filterA(numbers2, function(number){
//   return number % 2 != 0;
// });
// let oddNumbers = filter(numbers, (number) => number % 2 != 0);
function nombrePersona(first, last){
  this.first = first;
  this.last = last;
  this.nombreComplero = function(){
    return this.first+ ' ' + this.last
  }
}
var nn = new nombrePersona('PABLO','DOS SANTOS')
console.log(nn.nombreComplero())

let speedA = 90;
let messageB = speedA >= 120 ? 'opcion - 1': speedA >= 80 ? 'a': 'b';
let messageC = speedA >= 150 ? 'opcion - 2': speedA >= 81 ? 'a': 'b';

function addOne(number = 0){
  return number + 1
}
function addOne1(user = 'Pablo'){
  return `Hola ${user}`
}
console.log(addOne1())
//console.log(sum = (a,b)=>a+b)
var sdum=(a,b)=>{return a+b}
console.log(sdum(2,4))
let w3s = [1, 2, 4, 7, 3, 5, 6];
console.log('//////////////////////////////////')
w3s.forEach(function(w3){
  console.log(w3)
})
console.log('//////////////////////////////////')
w3s.forEach((w3)=>console.log(w3))
//array filter
let hyh = w3s.filter(function(w3){
  return w3 >5
})
console.log(hyh)
let hyhPar = w3s.filter(function(w3){
  return w3 % 2 == 0
})
console.log(hyhPar)

let hy = w3s.filter(function(w3){
  return w3 % 2 != 0
})
let haha = w3s.filter((w3)=>(w3<5))
console.log(haha)
var tmpv = [-5, 12, 3,12,12,14,1]
console.log('//////////////////////////////////////////////')
const varGrades = (temperatures) =>{
  return temperatures.filter((temp=> temp >= 0))
}
console.log(varGrades([-5, 12, 3]))
console.log('//////////////////////////////////////////////')

let popa = tmpv.filter(function(tmp){
  return tmp >10
})
console.log(popa)
console.log('//////////////////////////////////////////////')

popa = tmpv.filter((tm)=>(tm >10))
console.log(popa)
//BÃºsqueda de matriz (devoluciÃ³n de llamada)
const nnx = ['Sam','Israel','Pablo','Fabiean','Pablo'];
let nnxR = nnx.find(function(name){
    return name ==='Pablo';
})
console.log(nnxR)
nnxR = nnx.find((name)=>name ==='Pablo')
console.log(nnxR)
//map
nnxR = tmpv.map(function(nn){
  return nn *2
})
console.log(nnxR)
nnxR = tmpv.map(nn=>nn*2)
console.log(nnxR)
var c = [-5, 12, 3,12,12,14,1,21,22]

const getRaisedGrades = grades => {
  return grades.map(function(grade) {
      if (grade + 1 > 20) {
          return 20;
      }
      return grade + 1;
  }).join(";");
}
console.log(getRaisedGrades(c))

const getRaisedGradesV2 = grades =>{
  return grades.map(grade=>{
    if(grade +1 >20){
      return 20
    }
    return grade+1
  })
}
console.log(getRaisedGradesV2(c))
//busca cun ano
const f1 = (years, searchyears)=>{
  return years.find(year =>year === searchyears) 
}
const f2 = (years,searchyears)=>{
  return years.find(year => year ===searchyears)
}
const f3 = (years,searchyears)=>{
  return years.find(year =>year ===searchyears)}

  const getMessage = message => {
    if (message.endsWith(".")) {
        return message;
    }
    return message + ".";
}
let ng;
console.log(ng ='esta es una prueba para el replace.')
console.log(ng.replace('replace','metodo replace'))


/**
 * @param {string} name
 */
 const getSlug = name => {
  // start by lower casing the string
  let result = name.toLowerCase();
  // then get the first 15 characters
  result = result.substring(0, 15);
  // convert all the space characters to dashes
  result = result.replaceAll(" ", "-");
  // return result
  return result;
}

// Sample usage - do not modify
console.log(getSlug("IKEA tablesss")); // "ikea-table"
//console.log(getSlug("200cm Bed")); // "200cm-bed"
//console.log(getSlug("Bedside lavalamp")); // "bedside-lavalam"
//console.log(getSlug("A B C noodles")); // "a-b-c-noodles"

let fCC = "freeCodeCamp"; // Cambia esta lÃ­nea
let fact = "is cool!"; // Cambia esta lÃ­nea
fact = "is awesome!";
const FCC="freeCodeCamp"
fCC= fCC.toUpperCase();
console.log(FCC, fact); // Cambia esta lÃ­nea 

const myStr = "FirstLine\n\tSecondLine\n\ThirdLine"; // Cambia esta lÃ­nea
console.log(myStr)

const User = [{
    id: 1,
    name: 'pablo'
  },
  {
    id: 2,
    name: 'doe'
}]

const usera = [{
  id:1,
  nom:'Doe'
},{
  id:2,
  nom:'pablo'
}]
// var arruser = usera.map(user =>user.name)
// console.log(arruser)
//  var csv = arruser.join(', ')

 const csv = usera.map(user =>user.name).join(', ')
 console.log(csv);

 const numbers = [15,10,20,21];
 const allAbove10 = numbers.every(number =>numbers>=20);
 const allAbove15 = numbers.every(number =>numbers>=444);

 console.log(allAbove10);
 console.log(allAbove15);
 
 const shouldAdjustGrades = grades => {
  return grades.some(grade => grade < 10);
}


// Sample usage - do not modify
shouldAdjustGrades([10, 12, 10, 14]); // false
shouldAdjustGrades([12, 8, 17]); // true

const gr = grades => { 
  return grades.some(grade => grade < 10);
}
console.log(gr([10,10,3,10,10,10]));

let items = ["Pen", "Paper", "Staples"];
const deletedItem = items.splice(0,1); //remove one element at index 0
console.log(items); //[ 'Paper', 'Staples' ]

const resetApps = apps => {
  return apps.length = 0;
}

// Sample usage - do not modify
const apps = ["Calculator", "Whatsapp", "Chrome", "Firefox"]
console.log(resetApps(apps));

const appsA = ["Calculator", "Whatsapp", "Chrome", "Firefox"]
const removeFirstApp = apps => {
  apps.splice(0,1);
  return apps;
}
console.log(removeFirstApp(appsA));//[ 'Whatsapp', 'Chrome', 'Firefox' ]

/**#RESUME
 * El mÃ©todo Array .every(callback)regresa truecuando todos los elementos de la matriz cumplen la condiciÃ³n proporcionada en la devoluciÃ³n de llamada.
.some(callback)El mÃ©todo Array regresa truecuando al menos un elemento de la matriz cumple la condiciÃ³n proporcionada en la devoluciÃ³n de llamada.
Puede vaciar una matriz estableciendo su longitud en 0.
.splice(start[, deleteCount])elimina elementos de la matriz del startÃ­ndice. El nÃºmero de elementos que eliminarÃ¡ se especifica mediante deleteCount.
Si omite deleteCount, eliminarÃ¡ todos los elementos del startÃ­ndice. */

//Matriz reducir: multiplicaciÃ³n 

const num = [3, 2, 2];
let resu= num.reduce((total, current)=>{
    return total * current;
}, 1);
console.log(resu)


const num1= [3, 2, 2];
let resu2 = num1.reduce((total, current)=>{
    return total + current;
}, 0);
console.log(resu2)

//Usando .forEach
let numbers1=[3,3,3]
let sum2 = 0
numbers1.forEach(number=>{
  sum2 = sum2 + number
})
console.log(sum2);

//Usando .reduce
const sum = numbers.reduce((total, current) => {
  return total + current
}, 0);

//concatenaciÃ³n de matrices

const lat =[3,3]
const lng =[2,2]
const point = [...lat,...lng]
console.log(point);

const itemsA = ["Tissues", "Oranges"];

const otherItems = [...itemsA, "Tomatoes"];
console.log(otherItems); // ["Tissues", "Oranges", "Tomatoes"]

//Object.keys
const user = {
  id: 1,
  name: "Sam Green",
  age: 20
};

//const keys = Object.keys(user)

const settings = {
  theme: "Dark",
  version: "2.4.1",
  beta: false
};

const keys = Object.keys(settings);
console.log(keys); // ["theme", "version", "beta"]
keys.forEach(key => {
  // log the value of every key dynamically
  console.log(settings[key]);/**
  Dark
  2.4.1
  false 
  */
});

const key  = {
  llve:233,
  nni:10,
  pp0:'ee542'
}
const getUpperCasedProperties = course => {
  return Object.keys(course).map(key => key.toLocaleUpperCase());
}

let accs= getUpperCasedProperties(key)
console.log(accs)

const pf = course =>{
  const k = Object.keys(key)
  return k;
}

console.log(pf(key))

const usser = {
  id: 1,
  name: 'San Diego',
  age: 20

}
const value = Object.values(usser)
console.log(value)

const an4 = {
  p: 'xsm',
  t:'lsita'
}
let acas = Object.values(an4)
console.log(acas);

const entries = Object.entries(an4);
console.log(entries)

/**
 * 
 * Cuando acceda a una propiedad que no existe en un objeto, obtendrÃ¡ undefined.
Cuando intenta acceder a una propiedad o llamar a un mÃ©todo undefined(o una expresiÃ³n que se evalÃºa como undefined), obtendrÃ¡ un error Uncaught TypeError: Cannot read property 'X' of undefined.
Cuando vea [object Object], significa que se usÃ³ un objeto en un contexto que esperaba una cadena. Entonces, el .toString()mÃ©todo se ha llamado automÃ¡ticamente en el objeto.
El Object.values()mÃ©todo devuelve una matriz de los valores de un objeto.
El Object.entries()mÃ©todo devuelve una matriz de matrices que representan cada par clave/valor.
 */

const getUpperCasedValues = course => {
  return  Object.values(course).map(value =>value.toUpperCase())
}

// Sample usage - do not modify
console.log(getUpperCasedValues({name: "Learn JavaScript"})); // ["LEARN JAVASCRIPT"]
console.log(getUpperCasedValues({name: "Learn JavaScript", category: "Programming"})); // ["LEARN JAVASCRIPT", "PROGRAMMING"]

/**No puede usar la sintaxis de punto cuando la propiedad que intenta leer estÃ¡ almacenada en una variable o es el resultado de una expresiÃ³n (dinÃ¡mica).
En su lugar, debe usar corchetes con el nombre de la variable dentro. [key]por ejemplo
object[key]primero evaluarÃ¡ la keyexpresiÃ³n y luego leerÃ¡ la propiedad en funciÃ³n de su resultado.
El Object.keys(obj)mÃ©todo devuelve una matriz de todas las claves en el objque proporciona.
Cuando acceda a una propiedad que no existe en un objeto, obtendrÃ¡ undefined.
Cuando intenta acceder a una propiedad o llamar a un mÃ©todo undefined(o una expresiÃ³n que se evalÃºa como undefined), obtendrÃ¡ un error Uncaught TypeError: Cannot read property 'X' of undefined.
Cuando vea [object Object], significa que se usÃ³ un objeto en un contexto que esperaba una cadena. Entonces, el .toString()mÃ©todo se ha llamado automÃ¡ticamente en el objeto.
El Object.values()mÃ©todo devuelve una matriz de los valores de un objeto.
El Object.entries()mÃ©todo devuelve una matriz de matrices que representan cada par clave/valor.
Lo revisaremos Object.entries()mÃ¡s adelante en este curso. */

/**
 * const user = {name}.
const user = {age}es equivalente a const user = {age: age}.
 */

const usert = {
  id: 1,
  name: "Sam",
  isAdmin: true
};

const {id, name, isAdmin: admin} = usert;
// We've renamed isAdmin to admin while destructuring
console.log(admin); // true

const getUpperCasedProperties2 = course => {
  return Object.keys(course).length;
}

let accs2= getUpperCasedProperties2(key)
console.log(accs2)

const users = [{
  id:1,
  name:'sam doe'
},{
  id:2,
  name: 'pablo dos'
}];

var csv2 = users.map(user => user.name).join(', ')
console.log(csv2)

const userz= {
  details: {
      name: {
          firstName: "Sam"
      }
  },
  data: null
}
console.log(userz.details?.name?.firstName); 

const get = course => {
  return Object.keys(course).map(key => key.toUpperCase());
}


const data = {
  temperatures : [3,5,7,-3]
}

let primerValor = undefined;
if(data.temperatures){
  primerValor = data.temperatures[0];
}
console.log(primerValor);

//refactorizada
const segundoValor = data.temperatures?.[0]
console.log(segundoValor);
//Uso de encadenamiento opcional con funciones

const person = {
  age: 43,
  name: 'pa'
};

let upperCasedName = person.name; // might be undefined
if (person.name) {
  upperCasedName = person.name.toUpperCase?.()
}
console.log(upperCasedName);
console.log('hola')

//refactorizada
const resr = person.names?.toUpperCase()
console.log(resr);

let dataZ = {
  results:{
    grades: [4,4,3,2]
  }
}

const getFirstGrade = data => {
  if(dataZ.results && dataZ.results.grades){
    return data.results.grades[0]
  }
}
console.log(getFirstGrade(dataZ));
//refactorizado
const getf = data =>{
  const dt = data.results?.grades?.[0]
  return dt
}
console.log(getf(dataZ))

const nome ={
  info:{
    name: 'PAVJIE',
    a: 4
  }
}
//Using the nullish coalescing operator
const ffff = nome =>{
    return nome.info.name?.[2].toLowerCase()
}
console.log(ffff(nome));

const getName = nome => {
  return nome??"N/A incorrector"
}
console.log(getName(nome))//{ info: { name: 'PAVJIE', a: 4 } }
console.log(getName(null))//N/A incorrector

const nullValue = null;
const emptyText ='';
const someNumber = 34;

const valA = nullValue ?? 'entrara aqui si nullValue es null'
const valB = emptyText ?? 'entrara aqui si es null o vacio'
const valC = someNumber ?? 'devolvera el valor ya que no es null ni vacio'

//Assigning a default value to a variable
let foo = 4
const someDummyText = foo || "Hello!";
console.log(someDummyText);
const count = 0;
const text = "";

const qty = count || 42;
const message = text || "hi!";
console.log(qty); // 42 and not 0
console.log(message); // "hi!" and not ""
const defaultd = 'default'
let vvv = {
  persona: {
    hombre: 
      {
        nombre:'Pablo',
        edad:1}
  }}

console.log(vvv.persona.hombre.nombre?.toLocaleUpperCase()?? defaultd);

/**
 * @param {object} user
 * @param {string} [user.fullName]
 */
 const getWelcomeMessage = user => {
  if (user.fullName) {
      return `Welcome ${user.fullName}`;
  } else {
      return `Welcome user`;
  }
}


let userA = {
  fullName: 'pablo dos santosS'

}
console.log(getWelcomeMessage({fullName: "Sam Green"})); // "Welcome Sam Green"
console.log(getWelcomeMessage({})); // "Welcome user"

const getWelcomeMessage2ref = user =>{
  return `welcome ${userA.fullName }??  'user'`
  return `Welcome ${user.fullName ?? "user"}`;
}

console.log(getWelcomeMessage2ref(user));
//undefined significa que la propiedad aÃºn no ha sido definida. 
//null significa que la propiedad ha sido definida pero estÃ¡ vacÃ­a.

/**const user = {
    id: 1,
    name: "Sam",
    age: null
}

console.log(user.age); // null
console.log(user.birthday); // undefined
 */

const getPushMessage = status =>{
  if (status === 'recived'){
    return 'Restaruntant stated working on your order.';
  }else if(status === 'prepared'){
    return 'Driver is picking up your food'
  }else if(status === 'en_route'){
    return 'Drive is cycling your way!'
  }else if (status === "arrived"){
    return 'Enjoy yout food'
  }else{
    return "Unknown status"
  }
}
//funcion refactorizada
const getPushMessageFac = status =>{
  const message = {
    recived: 'Restaruntant stated working on your order',
    prepared: 'Driver is picking up your food.',
    en_rotue: 'Driver is cycling you way!',
    arrived: 'Enjoy your food'
  }
  return message[status] ?? 'Unknown status';
};
/**
 * @param {string} host
 * @param {string} user
 * @param {Object} booking
 * @param {string} bookinsg[].stsatus
 */

const getSt = ( host, user, booking)=> {
  const message = {
    pending: `hola ${user}, el estado es: pendiente HOST: ${host}`,
    confirmed: `Hola, ${user}tu pedido estado es: confirmado HOST: ${host}`
  };
  return message[booking.status] ?? 'Error desconocido'
}

const pedido = {
      status : 'pending'
}
console.log(getSt('209.290.190.11', 'pablo',pedido ));

//OPERADOR LOGICO EN LO OPUESTO
!true; // false
!false; // true
console.log(!true);//false

//MATRICES DE OBJETOS

const tweets = [
  {
      id: 1080777336298049537,
      message: "Hello Twitter ðŸ‘‹",
      created_at: "2020-01-03 11:46:00",
      author: {
          id: 109215315,
          firstName: "Jad",
          lastName: "Joubran",
          handle: "JoubranJad"
      }
  },
  {
      id: 1080777336298195435,
      message: "How do you keep track of your notes?",
      created_at: "2021-02-19 15:32:00",
      author: {
          id: 109216891,
          firstName: "Sam",
          lastName: "Green",
          handle: "SamGreen"
      }
  }
];
//recorre array de objetos
tweets.forEach (tweet=>{
  console.log(tweet.author.handle);
})
const results = [{
  date: "2018-12-13",
  grade: 14
}, {
  date: "2018-12-15",
  grade: 18
}]
const getSumOfGrades = results => {
  let sum = 0;
  results.forEach(result=>{
    sum += result.grade
  })  
  return sum;//total suma grados
};
console.log(getSumOfGrades(results));  //32
console.log('////////////////////////');
const getAverageAge = users => {
  let total = 0;
  users.forEach(user => total += user.age);
  return total / users.length;
};
//PROMEDIO
const sumaEdad = user =>{
  let total = 0;
  user.forEach(user => {
    total += user.grade
  })
  return total/user.length;
}
console.log(sumaEdad(results));
/**
* @param {string} users.name
 * @param {object} [users.subscription]
 * @param {object} [users.subscription.info]
 * @param {number} [users.subscription.info.value]
 */
const getTotalSales = users => {
    let tot = 0;
    users.forEach(user =>{
        tot += user.subscription?.info?.value ?? 0
        })
        return tot
}

// Sample usage - do not modify
const usersQ = [
    {id: 1, name: "Alex"},
    {id: 2, name: "Sam", subscription: {info: {value: 59}}},
    {id: 3, name: "Charlie", subscription: {info: {value: 31}}}
];
console.log(getTotalSales(users)); // 90

//Transformar arreglos de objetos 
const nomb = ['PedRO','jAVieR','ALEx']
const rss = nomb.map(n=>n.toUpperCase())
console.log(rss)//[ 'PEDRO', 'JAVIER', 'ALEX' ]
//MATRIZ DE OBJETO
const tweetsA = [
  {
      id: 1080777336298049537,
      message: "Hello Twitter ðŸ‘‹",
      created_at: "2020-01-03 11:46:00"
  },
  {
      id: 1080777336298195435,
      message: "How do you keep track of your notes?",
      created_at: "2021-02-19 15:32:00"
  }
];

const mess = tweetsA.map(n=>n.id);
console.log(mess);//[ 1080777336298049500, 1080777336298195500 ]

const aer = ['Pewwww','eekiei88e','ALExikiii']
const getnn= user =>{
  return user.map(u=>{
    return u.toUpperCase()
  })
}
console.log(getnn(aer));
console.log('////////////////////////////');
const petra = user=>{
  return user.map(u=>{
    return `${u.created_at} ${u.created_at}`
  })
}
console.log(petra(tweetsA));

//Matriz .filtro()
const arrP = [
  {
      id: 3,
      message: "How do you keep track of your notes?",
      stats: {
          likes: 3,
          retweets: 20
      },
      prop:{
      }
  },
  {
    id: 41241,
    message: "How do you keep track of your notes?",
    stats: {
        likes: 14,
        retweets: 20
    },
    prop:{
    }
  }
];
const usges = [{
  id: 33,
  idi:{
    flag:44
  }

},
{
  id: 1,
  idi:{
    flag:44
  }
}]
const dea = arrP.filter(filtro => {
return filtro.id<4
})
console.log('/////////////');
//retorno implicito
//tweets.filter(tweet => tweet.stats.likes > 30);
 const deaV2 = usges.filter(u=>u.id<2)
 const deav3 = usges.filter(u=>u.id>32)
 console.log(deaV2);//[ { id: 1, idi: { flag: 44 } } ]
 console.log(deav3);//[ { id: 33, idi: { flag: 44 } } ]
const getUpperCasedValuess = course => {
  const de = Object.values(course)
  return de
}
//console.log(getUpperCasedValuess(usges))
//##########################################3Array .buscar()################################################################
/**Llamar al .find()mÃ©todo en una matriz de objetos devolverÃ¡ el primer objeto que coincida con la condiciÃ³n que especifique 
 * en la devoluciÃ³n de llamada, o undefinedsi ningÃºn objeto satisface la condiciÃ³n . */

//  const searchId = 41241;
//  const tweet = tweets.find(tweet => tweet.id === searchId);
//  console.log(tweet); // {...} (2nd tweet object)

 const OPE =[{
      ID: 33
 },{
  ID: 33
 },
 {
  ID: 232
 }
]
const searchId2 = 33;
const busq = OPE.find(b=>b.ID === searchId2)
console.log(busq);

//##################Array .algunos() .some()
const tweetsC = [
  {
      id: 10512,
      message: "Hello Twitter ðŸ‘‹",
      stats: {
          likes: 41,
          retweets: 54
      }
  },
  {
      id: 41241,
      message: "How do you keep track of your notes?",
      stats: {
          likes: 14,
          retweets: 20
      }
  }
];
//tweetsC.some(tweet => tweet.stats.likes > 30); // true (at least one has more than 30 likes)
//tweetsC.some(tweet => tweet.stats.likes > 100); // false (none of the tweets satisfy this condition)
//#####################################Array .every()####################################Array .every()
//tweetsC.every(tweet => tweet.status.likes > 10); // true (all the tweets have more than 10 likes)
//tweetsC.every(tweet => tweet.status.likes > 30); // false (some tweets don't have more than 30 likes)

/**
 * tweets.every(tweet => tweet.status.likes > 10); // true (all the tweets have more than 10 likes)
tweets.every(tweet => tweet.status.likes > 30); // false (some tweets don't have more than 30 likes)
 */

//TAREAS

//FILTRA VALORES BOLEANOS 
/**
 * @param {Object[]} courses
 * @param {number}   courses.id
 * @param {string}   courses.name
 * @param {boolean}  courses.isCompleted = TRUE
 */
//FILTRA LOS VALORE 
 const getCompletedCourses = courses => {
  return courses.filter(c=>c.isCompleted)
}

const sampleGroups = [{
  id: 1,
  title: "Football",
  details: {
      messageCount: 30,
      isPublic: true
  }
}, {
  id: 2,
  title: "Family",
  details: {
      messageCount: 1014,
      isPublic: false
  }
}];
//ConversiÃ³n a CSV (valores separados por comas)
const cvs3 = sampleGroups.map(smp=>smp.title).join( ", " )
console.log(cvs3);

//DesestructuraciÃ³n de objetos
sampleGroups.forEach(s=>{/**30 true
                          1014 false */

   const {messageCount,isPublic}=s.details
   console.log(messageCount,isPublic)
})



const exportVerifiedUsers = users => {
   return users.filter(user => user.isVerified)
               .map(user =>user.name)  
               .join(", ")   
 
}
//matriz de numeros
const gradesM = [10, 15, 5];
//matriz de objeto
const gradesN = [{grade: 10}, {grade: 15}, {grade: 5}];
//REDUCE
/**
 * @param {Object[]} groups
 * @param {number} groups.id
 * @param {string} groups.title
 * @param {object} groups.details
 * @param {number} groups.details.messageCount
 * @param {boolean} groups.details.public
 */
// const sumMessageCount = groups => {
//   return groups.reduce((total, current) => {
//       console.log(current);
//       return total + current.details.messageCount;
//   }, 0);
// }

/**
 * @param {Object[]} products
 * @param {number} products.price
 * @param {number} products.quantity
 */
 const getCartTotal = products => {
  return products.reduce((total, current) => {
      console.log(current);
      return total + (current.price * current.quantity);
  }, 0);
}

// Sample usage - do not modify
const sampleProducts = [{
  price: 10,
  quantity: 3
}, {
  price: 5,
  quantity: 4
},{
  price: 3,
  quantity: 5

}]
console.log(getCartTotal(sampleProducts)); // 50

/**
 * @param {Object[]} recordings
 * @param {number} recordings.value
 */

const fnc = recordings =>{
  return recordings.reduce((total, current)=>{
    console.log(current)
    return total * current.price
  }, 1)
}
console.log(fnc(sampleProducts))

console.log('step-1')
try{ 
  funcionDesconocida('3')

}catch(error){
  console.log(error)
}
console.log('Despues del catch');

const addItem = (items, item) => {
  items.push(item)
  return items
}
const sampleProductsV1 = [{
  price: 10,
  quantity: 3,
  f:'delInfo'
}, {
  price: 5,
  quantity: 4,
  f: 'tnde qQ ESCOND FOR EVE'
},{
  price: 3,
  quantity: 5

}]

/**
* @param {string[]} items
*/
const exportLowerCasedCSV = items => {
  return items.map(item=>item.f)
}  
console.log(exportLowerCasedCSV(sampleProductsV1));

const expor = items =>{
    return items.map(function(item){
      return item.price
}).join('##################jaajaja##################')};

console.log(expor(sampleProductsV1));

/**Matrices y objetos
Las matrices y los objetos se consideran objetos en JavaScript.
Cuando escribe [], es lo mismo que crear una nueva instancia de Array.
Cuando escribe {}, es lo mismo que crear una nueva instancia de Object. */

new Array(); // creates []
new Object(); // creates {}

const array1 = new Array()
array1.push(10,10)
console.log(array1);
const objec1 = new Object()
objec1.keys = ['key','yek']
console.log(objec1);

const grades90 = [{
  id: 1,
  grade: 12,
  isPassing: false // we need to update this to true
}, {
  id: 1,
  grade: 14,
  isPassing: true
}];

const entry = grades90.find(grade => grade.id === 1);

entry.isPassing = true
console.log(entry);
console.log(entry);

/**
 * @param {array} users
 * @param {number} userId
 */
 const verifyUser = (users, userId) => {
  users = users.find(u=>u.id ===userId)
 return users.isVerified= true

}
// Sample usage - do not modify
const users45 = [{
 id: 1,
 name: "Sam",
 isVerified: false
}, {
 id: 2,
 name: "Alex",
 isVerified: false
}, {
 id: 3,
 name: "Charlie",
 isVerified: false
}];
verifyUser(users45, 2);
console.log(users45); // notice that it gets mutated

//Operaciones de matrices inmutables 

const gradesCV = [10, 20];
const gradesCopy = [...gradesCV];
console.log(gradesCopy); // [10, 20] (new array, not linked to 'grades')

/**Por otro lado, los que son inmutables son .filter()y .map()porque estos mÃ©todos devuelven una nueva matriz (en lugar de modificar la anterior).
   El .reduce()mÃ©todo tambiÃ©n es inmutable ya que devuelve un nuevo valor calculado a partir de una matriz. */

   //devuelve una nueva matriz (por lo que no afecta a la original). 
   const rec = [4,4,6];
   const upd = rec.filter(r=>r<5)
   console.log(upd);

   //copia superficil
   //[...originalArray].

   //EliminaciÃ³n inmutable
   const book = {
    id: 1,
    title: "Harry Potter",
    year: 2017,
    rating: 4.5
}

// GOOD: immutable
const {year, ...rest} = book;
console.log(rest); // { id: 1, title: "Harry Potter", rating: 4.5}
//CLASS
class PersonQ {
  constructor() {
      console.log("I was automatically called");
  }
}

// class usage
const personQ = new PersonQ; // () are optional when there are no arguments
class rc {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
}

const rc1 = new rc(1,1)

//console.log(rc1);
//Captura de parÃ¡metros del constructor

class clase{
  constructor(valorA, valorB){
    this.valorA = valorA;
    this.valorB = valorB;
    
  }
  getValores(){
    return `${this.valorA} ${this.valorB}`;
  }

}

const claseCreada = new clase('2','123')
console.log('/////////////////////////');

console.log(claseCreada.getValores())

// class definition
class UserClase {
  constructor(firstName, lastName, prefix, age) {
      this.firstName = firstName;
      this.lastName = lastName;
      this.prefix = prefix;
      this.age = age;
  }

  getFullName() {
      return `${this.prefix}. ${this.firstName} ${this.lastName}`;
  }

  canVote() {
      return this.age >= 18;
  }
}


// Sample usage - do not modify
const user1 = new UserClase("Sam", "Doe", "Mrs", 20);
console.log(user1.getFullName()); // "Mrs. Sam Doe"
console.log(user1.canVote()); // true
const user2 = new UserClase("Alex", "Green", "Mr", 17);
console.log(user2.getFullName()); // "Mr. Alex Green"
console.log(user2.canVote()); // false

//Llamar a un mÃ©todo de instancia desde otro
class UserClaseA {
  constructor(a,b){
    this.a = a;
    this.b = b;
  }
  fun(){
    return  this.a + this.b
  }
  getfun(){
    const sum =  this.fun();
    return `hola el resultado es:  ${sum}`;

  }
}
const userclaseA = new UserClaseA(2,2)
console.log(userclaseA.getfun());
//comrpendiendo clases js
class todos {
  constructor(){
    this.todos= [{
      cod: 'EP0000',
      mess: 'ACCEPT',
    },{
      cod: 'EP0023',
      mess: 'PENDING',
    }]
  }
  getAll(){
    this.todos
  }
  getCount(){
    this.todos.length;
  }
  add(cod,mess){
    this.todos.push({cod, mess})
  }
  getOK(){
    console.log(this.todos);
    return this.todos.filter(f=>f.cod=='EP0000')??`${this.todos.mess}`//<--arreglar, no retorna caso FALSE
  }

}

const codear = new todos()
console.log(codear.getOK());
//gettter and setter\/ 

/**
 * La definiciÃ³n de getters y setters en una clase se usa principalmente para validar o modificar ciertos
 *  valores antes de que se establezcan como propiedades en una clase.
Suponiendo una instancia user, el acceso user.agellamarÃ¡ get age()si existe el captador.
Suponiendo una instancia user, la configuraciÃ³n user.age = llamarÃ¡ set age(value)si existe el setter.
Al crear getters y setters, asegÃºrese de prefijar la nueva variable de instancia con un _para evitar la creaciÃ³n de un bucle infinito.
 */

console.log('////ENTRANDO A PAYMENTS');
class Payments {
  constructor(amount) {
    this.amount = amount;
  }
  get amount(){
    return this._cents;
  }
  set amount(value){
   
    return this._cents = value *100
  }
}
const pmt = new Payments(120)
console.log(pmt.amount);
class UserF {
  get age() {
      console.log("age getter");
      return this._age;
  }

  set age(value) {
      console.log("age setter");
      this._age = Number.parseInt(value, 10);
  }
}

console.log()

const userf = new UserF()
userf.age = 10
console.log(userf.age);

const objCreado ={
  objeto: 'string'
}
class Tasks {
  /**
  * @param {string[]} todos
  */
  constructor(todos) {
      this._todos = todos;
  }
  get todos(){
     return  this._todos.join(', ')
  }

}
const objTask = new Tasks(['111','11'])
console.log(objTask.todos);

//ENCADENAMIENTO DE METODOS//
class Course {
  constructor(name, isCompleted) {
      this.name = name;
      this.isCompleted = isCompleted;
  }

  markAsCompleted() {
      this.isCompleted = true;
      return this; // allows method chaining
  }

  setGrade(grade) {
      this.grade = grade;
      return this; // allows method chaining
  }

  requestCertificate() {
      this.askedForCertificate = true;
      return this; // allows method chaining
  }
}

class Discount {
  constructor() {
      this.amount = 1000;
  }

  applyDiscount() {
      if (Discount.isValid()) {
          this.amount = 500;
      }
  }

  static isValid() {
      return Math.random() <= 0.5; // 50% chance returns true
  }
}

// Sample usage - do not modify
console.log(Discount.isValid()); // true or false
const discount = new Discount;
discount.applyDiscount();
console.log(discount.amount); // either 1000 or 500

console.log('/////COMPRENDIENDO HERENCIAS///////////////');
///COMPRENDIENDO HERENCIA
//construccion de la clase empleado
class empleado {
  constructor() {
    this.primerNombre = primerNombre;
    this.apellido =  apellido;
    
  }
  consigueNombre(){
    return `${this.primerNombre} ${this.apellido}`
  }
  consigueIniciales(){
    return this.primerNombre[0] + this.apellido[0]
  }
  menssage(){
    console.log('funcion dentro de mensaje')
  }
}
//CLASE EMPLEADO CON HERENCIA
// class empleadoHerencia {
//   constructor(primerNombre, apellido){
//     this.primerNombre = primerNombre;
//     this.apellido     =  apellido;
//   }
//   consigueNombre(){
//     return `${this.primerNombre} ${this.apellido}`
//   }
//   consigueIniciales(){
//     return this.primerNombre[0]  + this.apellido[0]
//   }
// }
// class Manager extends empleadoHerencia{
//   send(){
//     console.log(`mensage dentro de funcion send`)
//   }
// }

//const heredableA = new empleadoHerencia('pablo', 'dos santos')
//var manager = new empl('a','a','f');
//console.log(manager.getPath()) ; // logs "Sent performance review for current quarter"
//manager.getFullName(); // "Sam Green"
//manager.getInitials(); // "SG"
//console.log();

class UserN{
  constructor(primerNombre, segundoNombre){
    this.primerNombre = primerNombre;
    this.segundoNombre = segundoNombre;
    this.edad = 18
    
  }

  nombreCompl(){
    return `${this.primerNombre} ${this.segundoNombre}`
  }
  canVote(){
    return this.edad
  }
}
class Admin extends UserN{
  nombreCompl(){
    return `${this.primerNombre} ${this.segundoNombre}`
  } 
}

const adminin = new Admin('pavlo', 'dos sant');
//SUPER 
class Emmm {
  constructor(name,lastname){
      this.name = name;
      this.lastname;

  }
  fullname(){
      return `${this.name}`
  }

}
class UserPOP {
  constructor(name,lastname){
      this.name = name;
      this.lastname;

  }
  fullname(){
      return `${this.name}`
  }

}
//EXTENDIDAD
class AdminN extends UserPOP {
  constructor(firstName, lastName, age, userType) {
      super(firstName, lastName, age);
      this.userType = userType;
  }
}
class clasePadre{
  constructor(parametroNombreClase1,parametroNombreClase2,parametroNombreClase3){
    this.parametroNombreClase1 =parametroNombreClase1;
    this.parametroNombreClase2 =parametroNombreClase2;
    this.parametroNombreClase3 =parametroNombreClase3;

  }
}
class nombreClase extends clasePadre{
  constructor(parametroNombreClase1, parametroNombreClase2, parametroNombreClase3){ //constructor de nombreClase
  super(parametroClasePadre1,parametroClasePadre2,parametroClasePadre2)
  this.parametroNombreClase3 = parametroNombreClase3
  }
}

//NUEVA CLASE
class coleccion{
  constructor(name, worth){
    this.name = name;
    this.worth = worth;
    contador= 0;
  }
  cuentaMensaje(){
    return `${this.name} ${this.worth}s coleccion`
  }
  coleccion(){
    this.contador++;
  }
  puntos(){
    return this.count * this.worth;
  }

}

// module.exports = class moneda extends coleccion{
//   constructor(){
//     super('coin',8)
//   }
// }

// module.exports = class gema extends coleccion{
//   constructor(){
//     super('gema', 80)
//   }
// }

//Herencia prototÃ­pica
function Gorilla(){

}
function Banana(){

}
function GorillaBanana(){

}
GorillaBanana.prototype.eat =  Gorilla.prototype.eat;
GorillaBanana.prototype.peel = Gorilla.prototype.peel;

class benvidos{
  Hola(){
    return 'HolaCtmre'
  }
}
class chao extends benvidos{
  childMetod(){

  }
}
const child = new chao();
Object.getPrototypeOf(child);

console.log(child.Hola())

class BookSale {
  constructor() {
      this.amount = 1000; // US cents
      this.currency = "usd";
      this.isStudent = false;
  }

  applyStudentDiscount() {
      this.isStudent = true;
      this.amount = 800;
      return this;
  }
  setCurrency(currency) {
      this.currency = currency;
      return this;
  }
  applyPercentageDiscount(percent) {
      this.amount = this.amount - this.amount * percent / 100;
      return this;
  }
}
// Sample usage - do not modify
const bookSale = new BookSale;
let ju = bookSale.applyStudentDiscount().setCurrency("eur").applyPercentageDiscount(5);
console.log(ju);
//campos de clase privada

class ggrup {
  #variablePrivada = 18;
  get variablePrivada(){
    return this.#variablePrivada
  }
  set variablePrivada(age){
    if(age >=18){
      return this.#variablePrivada = age
    }else{
      return 1
    }
  }
}

const hijoGgrup = new ggrup();
console.log(hijoGgrup.variablePrivada=10);

//MÃ©todos de instancias privadas
class UserZA {
  constructor(age) {
      this.age = age;
      this.#logAge();
  }

  #logAge() {
      console.log(this.age);
  }
}

const userZS = new UserZA(20);
// cannot call user.#logAge() or user.logAge()
class BookSale2 {
  #amount = 1000; // US cents
  #currency = "usd";
  #isStudent = false;

  applyStudentDiscount() {
      this.#isStudent = true;
      this.#amount = 800;
      return this;
  }

  setCurrency(currency) {
      this.#currency = currency;
      return this;
  }

  applyPercentageDiscount(percent) {
      this.#amount = this.#amount - this.#amount * percent / 100;
      return this;
  }
  
  getAmount() {
      return this.#amount;
  }
}
// Sample usage - do not modify
const bookSale2 = new BookSale2;
bookSale.applyStudentDiscount().setCurrency("eur").applyPercentageDiscount(5);
console.log(bookSale)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
console.log('a');
setTimeout(() => {
  console.log("este mensaje esta dentro del primer Setimeout");
}, 1);

console.log('c'); 

/**Â¿QuÃ© significa sincrÃ³nico y asincrÃ³nico?
Para explicar la diferencia entre cÃ³digo sincrÃ³nico y asincrÃ³nico, piense en la diferencia entre una conversaciÃ³n cara a cara y una conversaciÃ³n por mensaje de texto.

Una conversaciÃ³n cara a cara es sincrÃ³nica porque las personas hablan y responden inmediatamente una tras otra.
Sin embargo, una conversaciÃ³n por mensaje de texto es asincrÃ³nica porque los destinatarios pueden responder mÃ¡s tarde en el futuro. */

//Una conversaciÃ³n cara a cara es sincrÃ³nica porque las personas hablan y responden inmediatamente una tras otra.
const cfSum =((n)=>console.log(n))

const bienvenidoUsuario = (name, callback)=>{
  setTimeout(()=>{
    cfSum('dentro del callback')
    console.log(`variable nombre ${name} variable: `);
        //callback(); // call the success callback function
    }, 1);
  }
  bienvenidoUsuario('pablo',cfSum('3'))

   const sumGrades = (grades, callback) => {
    // simulate expensive operation
    setTimeout(() => {
        const sum = grades.reduce((total, current) => total + current, 0);
        if (callback) {
            callback(sum); // call the success callback with the sum
        }
    }, 1);
}


  const calcSumV2 = (g) =>{
    sumGrades(g, valor =>{
      console.log(`el valor es: ${valor}`);
    })
  }
  calcSumV2([2,2])

//   showLoader(() => {
//     getWeather((data) => {
//         // success callback
//         hideLoader(() => {
//             enableRefreshButton();
//             displayWeather(data, () => {
//                 logToAnalytics("weather");
//             });
//         });
//     }, () => {
//         // error callback
//         hideLoader(() => {
//             enableRefreshButton();
//         });
//     })
// });


//   a(()=>{
//     b((data)=>{
//       c(()=>{
//         d();
//          f(data, ()=>{
//           console.log('d');
//          });

//       });
//     }, ()=>{
//       c(()=>{
//         d();
//     });
//   })
// });

// const grv = [2,2,2];

// const semT=(t,v) => {
//   console.log(`el valor de semT V: ${t}`);
// }
//  //semT(grv)

//  //refactorizado para usar Promises 
//  const wait = milliseconds => {
//   return new Promise(resolve => {
//       setTimeout(() => {
//           resolve();
//       }, milliseconds);
//   });
// }
// console.log("A");
// wait(1900).then(() => {
//     // this runs when the wait(milliseconds) function has completed successfully
//     console.log("B");
// })
//console.log("C");

const wait  =  m =>{
  return new Promise(resolve=>{
    setTimeout(()=>{
      resolve();
      console.log('...##########dentro del wait#####################...');
    },m)
  })
}


const wait2 = m2 =>{
  return new Promise(resolve =>{
    setTimeout(()=>{
      resolve();
      console.log('...##########dentro del wait2#####################...');
    },m2)
  })
}

const wait3 = m3 =>{
  return new Promise(resolve=>{
    setTimeout(()=>{
      resolve();
      console.log('...##########dentro del wait3#####################...');
    },m3)
  })
}

const wait4 = m4 =>{
  return new Promise(resolve=>{
    setTimeout(()=>{
      resolve();
      console.log('...##########dentro del wait4#####################...');
    },m4)
  })
}

const wait5 = m5 =>{
  return new Promise(resolve=>{
    setTimeout(()=>{
      resolve();
      console.log('...##########dentro del wait5#####################...')
    },m5)
  })
}

const variable = mmn =>{
  return new Promise(resolve=>{
    setTimeout(()=>{
      resolve();

    },mmn)
  })
}
variable(8000).then(()=>{
  console.error('probabdo el error')
})
variable()
wait(2).then(()=>{console.log('sc');})
wait2(2).then(()=>{console.log('sc');})
wait3(2).then(()=>{console.log('sc');})
wait4(2).then(()=>{console.log('sc');})

const pro = (a,b,c)=>{
  return c(a,b)
}
const af3 =pro(3,3,(a,b)=>a+b);
console.log(`promesaaaaaaa ${af3}`);

const pro2 = (valor1,valor2,fn) =>{
  return  fn(valor1, valor2)
}
const afss = pro2(23,23,(a,b)=>a+b)
console.log(afss);
const w = m=>{
  return new Promise(resolve=>{
      setTimeout(()=>{
       resolved();
      },m)
  })
}
const w2 = m2=>{
  return new Promise(resolved=>{
    setTimeout(()=>{
      resolved();
        console.log(`prom`)
    },m2)
  })
}
w2(5000).then(()=>{
  console.log('entrando');
})


const w3  = m3=>{
  return new Promise(resolve=>{
    setTimeout(()=>{
      resolve();
    },m3)
  }
)}

const w4 = m4=>{
  return new Promise(resolve=>{
    setTimeout(()=>{
      resolve();
    },m4)
})
}

const w5 =m5=>{
  return new Promise(resolved=>{
    setTimeout(()=>{
      resolved();

  },m5)
 }
)}

const w6 = m6 =>{
  return new Promise(resolve=>{
    setTimeout(()=>{
      resolve();
    },m6)
  })
}

const w7 = m7 =>{
  return new Promises(resolve=>{
    setTimeout(()=>{
      resolve()
    },m7)
  })
}

const init =()=>{
  console.log('init');
  w3(4000).then(()=>{console.log('despues de 4 segundo')}
)}
init()

const init2 = () =>{
  console.log('init2');
  w4(2000).then(()=>{console.log('despues de 2 seugndos');})
}
init2()

const fakeFetch = () =>{
  return new Promise(resolve=>{
    const min =1;
    const max =3;
    const rand = Math.floor(Math.random() * (max - min +1)) + min;
    setTimeout(()=>{
      resolve()
    },rand * 1)
  })
}


const init3 = () => {
  fakeFetch().then(()=>{console.log('el fakeFetch a sido completado')}
  )}

  init3()

  const w8 = m8 =>{
    return new Promise(resolve=>{
      setTimeout(()=>{resolve()},m8)
    })
  }


 const statusW8 = w8(1000)
 console.log(statusW8);//Promise { <pending> }

 statusW8.then(()=>{console.log(statusW8)})//Promise { undefined }
// Una promesa puede tener 3 estados: pending, fulfilledy rejected.
// Cada promesa comienza con el pendingestado y luego se vuelve fulfilledcuando se ha 
// completado con Ã©xito. Las promesas le permiten ejecutar una devoluciÃ³n de llamada en el
// futuro cuando la promesa se haya completado con Ã©xito.
const city = ['amsterdam','tokyo']
const getWDes = (city)=>{
  return new Promise((resolve, rejected)=>{
    if(!city|| typeof city !== 'string'){
      rejected('El dato debe ser un string')
    }
    if(!["amsterdam", "tokyo"].includes(city.toLowerCase())){
      rejected('La ciudad debe ser amsterdam o tokyo')
    }
    setTimeout(()=>{
      if(city.toLowerCase()=="amsterdam"){
        resolve('Cloudy');
    }
    if(city.toLowerCase()=="tokyio"){
      resolve('sunny');
    }
    
  },1)
  })
}

const lwtD = nombreCiudad =>{
  getWDes(nombreCiudad).then(data=>{
    console.log(data);
  }
)}
lwtD('amsterdam')

const fakefetch2 = (endpoint) =>{
  return new  Promise((resolve, reject) =>{
    if(endpoint !=='endpoint'){
       reject('el endpoind no es carrecto')
    }
    const min =1;
    const max = 2;
    //const rand = Math.floor(Math.random() *()
    setTimeout(()=>{
      
    })
   
  })
}
// const rand = Math.floor(Math.random() * (max - min + 1)) + min;

const min =1;
const max = 5;
const aasd = Math.floor(Math.random()*(max - min+1)  + min)

 console.log(aasd);

 /**El rejectedestado de una promesa estÃ¡ destinado a cuando las cosas se rompen. Por ejemplo, 
  * un problema de conexiÃ³n de red. La devoluciÃ³n de llamada proporcionada a .catch(callback)se 
  * ejecutarÃ¡ si la promesa termina en el rejectedestado.
  * Una promesa comienza en el pendingestado y luego se resolverÃ¡ con Ã©xito ( fulfilled) o se rechazarÃ¡ 
  * con un error ( rejected).
  * TambiÃ©n es posible que una promesa nunca se resuelva (podrÃ­a ser un error de implementaciÃ³n o podrÃ­a deberse a 
  * que nunca se cumple la condiciÃ³n para resolver). */
 const fakeFetch3 = (endp)=>{
  return new Promise((resolve, reject) =>{
    if(endp !== 'a'){
      reject('El endpoint no es correctoOOOOOOOOOOOOOOOOOOOOOOOOOOO')
    }
    
    const min = 1;
    const max = 10;
    const rand  = Math.floor(Math.random() *(max - min + 1) + min)

    const dataRes = {
      departed: false,
      delayed: true
    }
    setTimeout(()=>{
      resolve(dataRes)
      console.log('entro a resolve y rand vale' , rand);
    },rand)
  })
 }

const fnFakeFetch3 = ()=>{
  fakeFetch3('a').then((data)=>{
    console.log(data);
  }).catch((err)=>{
    console.error(err);
  })
}

fnFakeFetch3()
///////////////////////////////////////////////////
const cityV2 = ['amsterdam','tokyo']
const getWDesV2 = (cityV2)=>{
  return new Promise((resolve, rejected)=>{
    if(!cityV2|| typeof cityV2 !== 'string'){
      rejected('El dato debe ser un string')
    }
    if(!["amsterdam", "tokyo"].includes(cityV2.toLowerCase())){
      rejected('La ciudad debe ser amsterdam o tokyo')
    }
    setTimeout(()=>{
      if(cityV2.toLowerCase()=="amsterdam"){
        resolve('CloudyVVVVVVVVVVVVVVVVV2222222-ULTIMO-EN-SALIR');
    }
    if(cityV2.toLowerCase()=="tokyio"){
      resolve('sunny');
    }
    
  },5000)
  })
}

const lwtDV2 = nombreCiudad =>{
  getWDesV2(nombreCiudad).then(data=>{
    console.log(data);
  }
)}
lwtDV2('amsterdam')

function fetchData() {
  return new Promise((resolve, reject) => {
    // do some asynchronous work (such as making an HTTP request)
    const data = getDataFromAPI();
    if (data) {
      // if the asynchronous operation was successful, resolve the promise
      resolve(data);
    } else {
      // if the asynchronous operation failed, reject the promise
      reject(new Error('Failed to fetch data'));
    }
  });
}

fetchData()
  .then(data => {
    // handle the successful result
    console.log(data);
  })
  .catch(error => {
    // handle the error
    console.error(error);
  });

const getWeatherIn =(city)=>{
  return new Promise((resolve, rejected) => {
    if(!city || typeof city !== 'string'){
      rejected('El dato debe ser un string')
      if(!['amterdam', 'tokyo'].includes(city).toLowerCase()){
        rejected('El dato debe ser amsterdam o tokyo') 
    }
    setTimeout(() => {
      if(city.toLowerCase() === 'amterdam'){
        resolve('amterdam ha sido encontrado')
      }
      if(city.toLowerCase() === 'tokyo'){
        resolve('tokyo ha sido encontrado')
      }
  })
  }
})
}


  getWeatherIn("Amsterdam")
    .then(data => {
        console.log(data);
        console.log("Done fetching weather");
    })
    .catch(error => {
        console.error(error);
        console.log("Done fetching weather");
    });


const getWeatherIn2 = (city)=>{
  return new Promise((resolve, rejected)=>{
    if(!city || typeof city !== 'string'){
      rejected('rejected')
    }
    if(!['amsterdam', 'tokyo'].includes(city.toLowerCase())){
      rejected('rejected')
    }
    setTimeout(()=>{
      resolve('resolve')
    },6000)
  })

}


  getWeatherIn2("Amsterdam")
  .then(data => {
    console.log(data);
    console.log('dentro del then');
  })
  .catch(error =>{
    console.error(error);
    console.log('dentro del error');

  })
  const refactorGetWeatherIn=(city) =>
  {
    return new Promise((resolve, reject)=>{
      if(!city ||  typeof city !== 'string'){
        reject('reject')
      }
      if(!['amstermad','tokyo'].includes(city.toLowerCase())){
        reject('reject')
      }
      setTimeout(()=>{
        if(city.toLowerCase()=='amsterdam'){
          resolve('resolve')
        }
        if(city.toLowerCase()=='amsterdam'){
          resolve('resolve')
        }
      })
    })
  }
  //finally(): //REFACTORIZANDO

  refactorGetWeatherIn("Amsterdam")
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        console.error(error);
    })
    .finally(() => {
        console.log("Done fetching weather");
      });
      
      const RechProm =()=>{
        return new Promise((resolve, reject) =>{
          resolve()
        }
      
      )}
    //Rechazar manualmente una promesa
    RechProm("Amsterdam")
    .then(data => {
        throw new Error("STOOOOPEDDDDD ERROR.");
        console.log(data);
        console.log("Done fetching weather");
    })
    .catch(error => {
        console.error(error);
        console.log("CATCH ERRRORRRRR");
    });

// try...catch no funciona con promesas porque las promesas son asÃ­ncronas.
// Se usa .catch()para manejar errores con promesas.
// Se .finally(callback)ejecuta despuÃ©s de .then()cuando la promesa se resuelve correctamente
// y despuÃ©s de .catch()cuando la promesa se rechaza.
// .finally(callback)se puede utilizar para detener un cargador en ambos casos (Ã©xito y error).


let g = [10,10,23,44,55,11,55,23]
let nn = ['diego','pablo','thais']
function getNG(g){
    return g.length;
}
console.log(getNG(g)); //8
function lastChar(name){
    return name[name.length - 1];
}
console.log(lastChar(nn));//thais

function getDes(text){
    if(text.length > 0){
        return text.substring(0, 10)+ '...'
    }
    return text;
}

function elementoAdd(element, add){
    return element.push(add)
}
console.log(elementoAdd(g,99));
console.log(g);//[10, 10, 23, 44, 55,11, 55, 23, 99]

const varg = g.forEach(function(grades){
    console.log(grades);//lista g
})
let filtro = g.filter(function(grades){
console.log(grades);//lista);
})

function buscaAnos(anos, buscaAnos){
    return anos.find(function(anos){
        return  anos === buscaAnos;
    })
}
console.log(buscaAnos(nn, 'diego'));//diego
//let nn = ['diego','pablo','thais']
nn.map(function(strings){
    console.log(strings.length);// 5 5 5
}).length
//[10, 10, 23, 44, 55,11, 55, 23, 99]
function filtro20(g){
    return g.filter(function(gr){
        return gr >= 20

    })
}
console.log(filtro20(g));//[ 23, 44, 55, 55, 23, 99 ]
function  filtro50(g){
    return g.filter(function(gr){
        return gr >= 50
    }
)}
console.log(filtro50(g));//[ 55, 55, 99 ]
var esMayor = 19 > 18 ? 'es mayor' : 'no es mayor';
var esMenor = 19 < 18 ?true:false
console.log(esMayor)//es mayor
console.log(esMenor);//false

var primerCheck =  false,
    segundoCheck = false,

    access = primerCheck ? "Acceso denegado" : segundoCheck ? "Acceso denegado2" : "Acceso no autorizado";

console.log( access );//Acceso denegado
var arr = ['a','b', 'c']

//Desestructuracion de array
function printFullName(name) {
  console.log(name);
  // TODO: write your code below this line

      const[first,last] = name
  return `${first} ${last}`;
}
//Destructuring from functions
//repaso Inmutabilidad
new Array() === new Array(); //false
new Object() === new Object(); //false

const arr1 = new Array();
arr1.push(10);
const arr2 = new Array();
arr2.push(10);
arr1 === arr2; //false

const obj1 = new Object();
obj1.key = "something";
const obj2 = new Object();
obj2.key = "something";
obj1 === obj2; //false
function question1() {
  const grades = [10, 20, 30];
  const report = grades;
  grades.push(40);
  console.log(grades === report)
  // return the result of grades === report
  return true;
}

function question2() {
  const user = {
      id: 1,
      name: "Sam"
  };
  const admin = user;
  admin.is_admin = true;
  const guest = admin;
  // return the result of guest === user
  return true;
}


const result = [...numbers, 4];
console.log(result); //[1, 2 ,3 ,4]

function replaceApp(apps, oldApp, newApp) {
  return apps.map(app =>{
      if(app === oldApp){
          return newApp
      }
      return app
  })

}

// Sample usage
const apps1 = ["Calculator", "Phone"];
// Replace Calculator with Phone
const newApps1 = replaceApp(apps1, "Calculator", "Phone");

function Grades(){
  const grades = [8, 18, 10, 7, 14];

  // this will generate a warning (keep reading)
  return <ul>
      {
          grades.map(grade => {
              return <li>{grade}</li>
          })
      }
  </ul>;
}
//Agregar clave/valor de forma inmutable

//BAD: mutates => 
data.age = 18;
console.log(data); // {id: 1, name: "Sam", age: 18}
//GOOD: immutable
const newObjA = {...data, age: 18}
console.log(newObj); // {id: 1, name: "Sam", age: 18}

const data = {
  id: 1,
  age: 19
}

// GOOD: immutable
const newObj = {...data, age: 20};
console.log(newObj); // {id: 1, age: 20}
console.log(data); // original object did not change {id: 1, age: 19}

function attachUserType(user, type) {
  return {...user, type: type}
}

// Sample usage
const user1A = {
  name: "Sam",
  has_paid: true
}
const newUser12 = attachUserType(user1, "admin");
console.log(newUser12);
// check if the operation was immutable
console.log(newUser12 === user1); // immutable when it returns false


































































